{"name":"Minuit","tagline":"Propositions for a post-OSC prototypal protocol","body":"Minuit\r\n======\r\n\r\n**Propositions for a post-OSC prototypal protocol**\r\n\r\nWe propose some specifications for a query system based on OSC, coined here Minuit.\r\nIt has been discussed and refined by the protocol workgroup of the Virage platform on november 26th 2008.\r\n\r\n###Structure\r\nWe define a namespace as a tree-structure of OSC addresses, sorted in nodes binding on objects which have attributes.\r\n\r\n###Syntax\r\nIt has been decided that queries and replies should be separated from the address for optimization’s sake.\r\nThe type of message is then possible to filter based on tree specific characters into the first word of the message :\r\n* a slash at start (/) indicates an OSC “standard“ command to the specified address (this includes addressing attributes)\r\n* a question mark (?) indicates a query.\r\n* a colon (:) indicates a reply to a query, and duplicates the query’s syntax (colon is also used further to separate attributes from address)\r\n* a exclamation mark (!) indicates an error.\r\n\r\nIt turns out that the namespace can be handle using 4 differents operations :\r\n* discovering (using **namespace**) : asks for the names of nodes and the types of objects on the next tree-structure level. The request allows also to get the attributes at the current tree-structure level.\r\n* getting (using **get**) : gets the value of a particular attribute in an object.\r\n* setting (using the standard OSC style) : sets the value of a particular attribute of\r\nan object in the tree.\r\n* listening (using **listen**) : enable or disable listening of the value of a particular attribute of an object in the tree. When a listening is enabled, the value would be sent as a reply to the application which ask for.\r\n\r\nHereafter we consider an application A (IP, port) and an application B (IP, port) which are aware of each other’s existence on a network.\r\n~~~\r\nB would talk to A like that :\r\nB?operation /whereTo ... (the rest depends on the operation)\r\n\r\nA would replies to B using :\r\nA:operation /whereTo ... (the rest depends on the operation)\r\n~~~\r\n\r\n###Discovering\r\n~~~\r\nB?namespace /WhereToDiscover\r\nA:namespace /WhereToDiscover ObjectType nodes={ name1 name2 ...} attributes={ attributes of the object under the whereToDiscover node }\r\n~~~\r\n\r\nImportant note : considering the genericity of this approach any types and attributes can be shared using this exchange format. However, to ensure interoperability between systems, we have to define standard object types and attributes (see below for a proposition of attributes name).\r\n\r\n###Getting\r\n~~~\r\nB?get /WhereToGet:attribute \r\nA:get /WhereToGet:attribute value\r\n~~~\r\n\r\n###Setting\r\n~~~\r\n/WhereToSet value (this is standard OSC) no reply from A.\r\n~~~\r\n\r\n###Listening\r\n~~~\r\nB?listen /WhereToListen:attribute enable (turn on the listening) \r\nB?listen /WhereToListen:attribute disable (turn off the listening)\r\n\r\nA:listen /WhereToListen:attribute value (each time the attribute change if the listening is turned on)\r\n~~~\r\n\r\n###Object types\r\nThere are 4 types of objects : \r\n* **Application** : the root of the tree structure.\r\n* **Container** : a node of the tree structure which is not handling a value but provides features to manage the sub tree structure.\r\n* **Data** : a node a the tree structure which handles a value.\r\n* **none** : no object.\r\n\r\n###Data Attributes\r\nThere are many attributes for the Data object. Here is a first overview :\r\n* **value** : the value attribute is implicitly linked to the address, and then can be ommitted.\r\n* **type** : the possible types are : integer, decimal, string, generic, boolean, none, array.\r\n* **service**\r\nwhat kind of access the value provides : parameter (read+write), message (write), return (read).\r\n* **priority** : this a number used to order the setting of several object values in the same time. Smaller the number is the sooner it would receive the value. 0 means this object don’t care about order.\r\n* **rangeBounds** : an array of two values of the specified type.\r\n* **description** : textual description of what is the Data for.\r\n\r\n###Example\r\nBelow is an example of dialog between 2 environments. In this case, this is the namespace discovery of a Max patcher (using Jamoma 0.6 framework) by the i-score Sequencer :\r\n\r\n~~~\r\ni-score?namespace /\r\nJamoma:namespace / Application nodes={ filter input recorder } attributes={ debug version type name author }\r\ni-score?namespace /filter\r\nJamoma:namespace /filter Container nodes={ gain q } attributes={ tag service description priority }\r\ni-score?namespace /filter/gain\r\nJamoma:namespace /filter/gain Data attributes={ rangeBounds service active tag type repetitionsFilter description priority valueDefault value }\r\n~~~\r\n\r\n~~~\r\ni-score?get /filter/gain \r\nJamoma:get /filter/gain 90\r\ni-score?get /filter/gain:rangeBounds \r\nJamoma:get /filter/gain:rangeBounds 0 127\r\n~~~\r\n\r\n~~~\r\ni-score?listen /filter/gain enable\r\nJamoma:listen /filter/gain:value 53 \r\nJamoma:listen /filter/gain:value 54 \r\nJamoma:listen /filter/gain:value 55\r\n~~~\r\n\r\n~~~\r\ni-score?get /foo\r\nJamoma!get /foo\r\n~~~\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}