<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AUTHOR</key>
	<string></string>
	<key>CONTROLS</key>
	<array/>
	<key>DESCRIPTION</key>
	<string></string>
	<key>MODULE_AUTOFLUSH</key>
	<false/>
	<key>MODULE_CONTROL_ID_COUNTER</key>
	<integer>1</integer>
	<key>MODULE_LAYER_CONTEXTUAL</key>
	<false/>
	<key>MODULE_RESETDIRECTKEY_PAUSED</key>
	<true/>
	<key>MODULE_TITLEBAR_B</key>
	<real>0.20392157137393951</real>
	<key>MODULE_TITLEBAR_G</key>
	<real>0.13333334028720856</real>
	<key>MODULE_TITLEBAR_R</key>
	<real>0.08235294371843338</real>
	<key>PREFERENCES</key>
	<dict>
		<key>SCRIPT_STATE</key>
		<string>PLAYING</string>
		<key>WINDOW_HIDDEN</key>
		<false/>
		<key>WINDOW_MINIMIZED</key>
		<false/>
		<key>WINDOW_X</key>
		<real>16</real>
		<key>WINDOW_Y</key>
		<real>892</real>
	</dict>
	<key>SCRIPT_CLEANUP</key>
	<string></string>
	<key>SCRIPT_DESERIALIZE</key>
	<string></string>
	<key>SCRIPT_EVENT</key>
	<string></string>
	<key>SCRIPT_INIT</key>
	<string>from pprint import pprint
import copy
#make a dictionary with the whole namespace we want to use. This is done when loading the module
#It will be quicker after to just update or query the dictionary

m_app = {'author':'garagecube','name':'modul8','version': modul8.getValue('info_version',0),'project':modul8.getValue('info_projectName',0)}
m_db = {}
m_temp = {}
auto_priority_index = 0
m_master = {}

#if keyword as a '_' in its name, the first part is a node, and the other part needs to be evaluated again
def strip_node_leaf(layer_dict_name,m_keyword, valueKeyw):
	# it is a parameter : 
	if len(m_keyword) == 1:
		m_keyword = m_keyword[0]
		m_keyword = str(m_keyword)
		make_leaf(layer_dict_name,m_keyword, valueKeyw)
		#print 'LEAF', layer_index , m_keyword
	# it is a node and a parameter : 
	else: 
		make_node(layer_dict_name  , m_keyword, valueKeyw)
		#print 'NODE', layer_index , m_keyword[0]

# register a parameter					
def make_leaf(layer_dict_name,m_keyword, valueKeyw):
	pass
	m_temp.update(dict([(m_keyword , dict([('value' , valueKeyw),('priority',auto_priority_index)]))]))
	m_db.update(dict([(layer_dict_name , dict(m_temp) ) ] ) )												
def make_node(layer_dict_name , m_keyword,valueKeyw):
	if len(m_keyword) &gt; 0:
		if len(m_keyword) == 2:
			m_keyword = {m_keyword[0]:{m_keyword[1]:{'value': valueKeyw,'priority': auto_priority_index}}}
		elif len(m_keyword) ==3:				
			m_keyword = {m_keyword[0]:{m_keyword[1]:{m_keyword[2]:None}}}
	########################################################
	#the following line doesn't work - it replace the dict instead of updating it.
	########################################################
	m_db.update({'layer':{layer_index:m_keyword}})

for keyword in modul8.getValue ('info_keywords',0) :
	# m_keyword is the minuit keyword :  slash replaces underscore
	m_keyword = copy.deepcopy(keyword)
	#List of master controls
	if keyword.startswith ('ctrl_master') :			
		valueKeyw = modul8.getValue (keyword,0)
		keyword = keyword.split('_')[2:]
		auto_priority_index = auto_priority_index + 1
		keyword = '/'.join(keyword)
		m_master[keyword] = dict([('value' , valueKeyw),('priority',auto_priority_index)])
		m_db.update(dict([('master',m_master)]))
		#print  'MASTER_NAMESPACE', keyword , valueKeyw, auto_priority_index
	elif keyword.startswith ('ctrl_layer') :
		#print '#######',keyword
		if keyword == 'ctrl_layerStack_focusPosition' or keyword == 'ctrl_layerStack_positionChange' or keyword == 'ctrl_layer_focused' or keyword == 'id' or keyword == 'ctrl_layer_stackPosition' or keyword == 'ctrl_layerStack_duplicate' or keyword == 'ctrl_layer_activated' or keyword == 'ctrl_layer_id':
			keyword = None
		else:
			m_keyword = m_keyword.split('_')[2:]
			auto_priority_index = auto_priority_index + 1
			# if layer exist, alors il faut passer Ã  la suite
			for layer_index in range(1,3):
				layer_dict_name = 'm_layer'+str(layer_index)
				# fill-in the dict
				valueKeyw = modul8.getValue(keyword,layer_index)
				strip_node_leaf(layer_dict_name,m_keyword, valueKeyw)
							
#print m_app					
#print m_temp	
# print master dictionary
#print 'DATABASE' , m_db
pprint(m_db)
#for keys in m_db.keys():
#	pprint m_db.items()
#print m_temp
# print layer dictionary
#print m_layer_1

#def minuit_get(node):
#	if node == '/':
#		minuit_answer = '/' + ' ' + 'Application' + ' ' + 'nodes={master, layer , ui}'
#		print minuit_answer
#		return minuit_answer
#	elif '/master/' in node:
#		minuit_answer = '/master' + ' ' + 'Container' + ' ' + 'nodes={' +  ' '.join(ctrlKeywordMasterList) + '}' + ' ' + 'attributes={ priority }'
#		print  minuit_answer
#		return minuit_answer
#	elif '/layer.' in node:
#		minuit_answer = '/' + ' ' + 'Container' + ' ' + 'nodes={master, layer , ui}'
#		print minuit_answer
#		return minuit_answer
#	elif ':' in node:
#		minuit_answer = '/' + ' ' + 'Container' + ' ' + 'nodes={master, layer , ui}'
#		print minuit_answer
#		return minuit_answer
#	else:
#		print 'NON'
#
#minuit_get('/')
#minuit_get('/master')
#minuit_get('/master/still')
#minuit_get('/layer.1')
#minuit_get('/layer.10')</string>
	<key>SCRIPT_KEYWORDEVENT</key>
	<string></string>
	<key>SCRIPT_MESSAGE</key>
	<string></string>
	<key>SCRIPT_PAUSEEVENT</key>
	<string></string>
	<key>SCRIPT_PERIODICAL</key>
	<string></string>
	<key>SCRIPT_SERIALIZE</key>
	<string></string>
	<key>SHORT_DESCRIPTION</key>
	<string></string>
	<key>VERSION</key>
	<string></string>
	<key>WINDOW_HEIGHT</key>
	<real>150</real>
	<key>WINDOW_WIDTH</key>
	<real>150</real>
</dict>
</plist>
