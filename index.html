<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Minuit by Minuit</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Minuit</h1>
        <p>Propositions for a post-OSC prototypal protocol</p>

        <p class="view"><a href="https://github.com/Minuit/minuit">View the Project on GitHub <small>Minuit/minuit</small></a></p>


        <ul>
          <li><a href="https://github.com/Minuit/minuit/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/Minuit/minuit/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/Minuit/minuit">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a name="minuit" class="anchor" href="#minuit"><span class="octicon octicon-link"></span></a>Minuit</h1>

<p><strong>Propositions for a post-OSC prototypal protocol</strong></p>

<p>We propose some specifications for a query system based on OSC, coined here Minuit.
It has been discussed and refined by the protocol workgroup of the Virage platform on november 26th 2008.</p>

<h3>
<a name="structure" class="anchor" href="#structure"><span class="octicon octicon-link"></span></a>Structure</h3>

<p>We define a namespace as a tree-structure of OSC addresses, sorted in nodes binding on objects which have attributes.</p>

<h3>
<a name="syntax" class="anchor" href="#syntax"><span class="octicon octicon-link"></span></a>Syntax</h3>

<p>It has been decided that queries and replies should be separated from the address for optimization’s sake.
The type of message is then possible to filter based on tree specific characters into the first word of the message :</p>

<ul>
<li>a slash at start (/) indicates an OSC “standard“ command to the specified address (this includes addressing attributes)</li>
<li>a question mark (?) indicates a query.</li>
<li>a colon (:) indicates a reply to a query, and duplicates the query’s syntax (colon is also used further to separate attributes from address)</li>
<li>a exclamation mark (!) indicates an error.</li>
</ul><p>It turns out that the namespace can be handle using 4 differents operations :</p>

<ul>
<li>discovering (using <strong>namespace</strong>) : asks for the names of nodes and the types of objects on the next tree-structure level. The request allows also to get the attributes at the current tree-structure level.</li>
<li>getting (using <strong>get</strong>) : gets the value of a particular attribute in an object.</li>
<li>setting (using the standard OSC style) : sets the value of a particular attribute of
an object in the tree.</li>
<li>listening (using <strong>listen</strong>) : enable or disable listening of the value of a particular attribute of an object in the tree. When a listening is enabled, the value would be sent as a reply to the application which ask for.</li>
</ul><p>Hereafter we consider an application A (IP, port) and an application B (IP, port) which are aware of each other’s existence on a network.</p>

<pre><code>B would talk to A like that :
B?operation /whereTo ... (the rest depends on the operation)

A would replies to B using :
A:operation /whereTo ... (the rest depends on the operation)
</code></pre>

<h3>
<a name="discovering" class="anchor" href="#discovering"><span class="octicon octicon-link"></span></a>Discovering</h3>

<pre><code>B?namespace /WhereToDiscover
A:namespace /WhereToDiscover ObjectType nodes={ name1 name2 ...} attributes={ attributes of the object under the whereToDiscover node }
</code></pre>

<p>Important note : considering the genericity of this approach any types and attributes can be shared using this exchange format. However, to ensure interoperability between systems, we have to define standard object types and attributes (see below for a proposition of attributes name).</p>

<h3>
<a name="getting" class="anchor" href="#getting"><span class="octicon octicon-link"></span></a>Getting</h3>

<pre><code>B?get /WhereToGet:attribute 
A:get /WhereToGet:attribute value
</code></pre>

<h3>
<a name="setting" class="anchor" href="#setting"><span class="octicon octicon-link"></span></a>Setting</h3>

<pre><code>/WhereToSet value (this is standard OSC) no reply from A.
</code></pre>

<h3>
<a name="listening" class="anchor" href="#listening"><span class="octicon octicon-link"></span></a>Listening</h3>

<pre><code>B?listen /WhereToListen:attribute enable (turn on the listening) 
B?listen /WhereToListen:attribute disable (turn off the listening)

A:listen /WhereToListen:attribute value (each time the attribute change if the listening is turned on)
</code></pre>

<h3>
<a name="object-types" class="anchor" href="#object-types"><span class="octicon octicon-link"></span></a>Object types</h3>

<p>There are 4 types of objects : </p>

<ul>
<li>
<strong>Application</strong> : the root of the tree structure.</li>
<li>
<strong>Container</strong> : a node of the tree structure which is not handling a value but provides features to manage the sub tree structure.</li>
<li>
<strong>Data</strong> : a node a the tree structure which handles a value.</li>
<li>
<strong>none</strong> : no object.</li>
</ul><h3>
<a name="data-attributes" class="anchor" href="#data-attributes"><span class="octicon octicon-link"></span></a>Data Attributes</h3>

<p>There are many attributes for the Data object. Here is a first overview :</p>

<ul>
<li>
<strong>value</strong> : the value attribute is implicitly linked to the address, and then can be ommitted.</li>
<li>
<strong>type</strong> : the possible types are : integer, decimal, string, generic, boolean, none, array.</li>
<li>
<strong>service</strong>
what kind of access the value provides : parameter (read+write), message (write), return (read).</li>
<li>
<strong>priority</strong> : this a number used to order the setting of several object values in the same time. Smaller the number is the sooner it would receive the value. 0 means this object don’t care about order.</li>
<li>
<strong>rangeBounds</strong> : an array of two values of the specified type.</li>
<li>
<strong>description</strong> : textual description of what is the Data for.</li>
</ul><h3>
<a name="example" class="anchor" href="#example"><span class="octicon octicon-link"></span></a>Example</h3>

<p>Below is an example of dialog between 2 environments. In this case, this is the namespace discovery of a Max patcher (using Jamoma 0.6 framework) by the i-score Sequencer :</p>

<pre><code>i-score?namespace /
Jamoma:namespace / Application nodes={ filter input recorder } attributes={ debug version type name author }
i-score?namespace /filter
Jamoma:namespace /filter Container nodes={ gain q } attributes={ tag service description priority }
i-score?namespace /filter/gain
Jamoma:namespace /filter/gain Data attributes={ rangeBounds service active tag type repetitionsFilter description priority valueDefault value }
</code></pre>

<pre><code>i-score?get /filter/gain 
Jamoma:get /filter/gain 90
i-score?get /filter/gain:rangeBounds 
Jamoma:get /filter/gain:rangeBounds 0 127
</code></pre>

<pre><code>i-score?listen /filter/gain enable
Jamoma:listen /filter/gain:value 53 
Jamoma:listen /filter/gain:value 54 
Jamoma:listen /filter/gain:value 55
</code></pre>

<pre><code>i-score?get /foo
Jamoma!get /foo
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/Minuit">Minuit</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>